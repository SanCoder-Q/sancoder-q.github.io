---
layout: post
title: "Translate: Stackless Scala With Free Monads"
---

<div id="outline-container-org0eda3a3" class="outline-2">
<h2 id="org0eda3a3"><span class="section-number-2">1</span> Motivation</h2>
<div class="outline-text-2" id="text-1">
<p>
由于最近经常在生产中使用 <code>Free Monad</code> 范式, 所以就顺带看了看 <code>cats.Free</code> 的实现, 发现其实现方式和我想想中的 <code>Free</code> 不太一样, 除了 <code>Pure</code> (<code>Return</code>), <code>Suspend</code> 两种状态之外, 还有一个 <code>FlatMapped</code> 状态. 这样做看上去是为了将 <code>flatMap</code> 的 evaluation 延迟至 transform 期间完成, 但还是隐隐感觉和堆栈安全有关. 顺带想起关于 Scala FP 的堆栈安全一直是自己知识体系的一个空白, 因此就有了翻译 <code>Stackless Scala With Free Monads</code> 这篇论文的冲动, 期望这个工作能 drive 自己搞清楚 <b>Trampolining</b>.
</p>
</div>
</div>

<div id="outline-container-org0c4777f" class="outline-2">
<h2 id="org0c4777f"><span class="section-number-2">2</span> Stackless Scala With Free Monads</h2>
<div class="outline-text-2" id="text-2">
<p>
这篇论文是 Rúnar Bjarnason 在 2012 年的 Scala Days Conf 上发表并演讲的主题, 通过引入 Trampolining 范式(堆换栈, 感觉和 CPS 的理念很相似) 来解决 Scala 编译器无法完全尾调用优化的问题.
会议演讲视频: <a href="http://skillsmatter.com/podcast/scala/stackless-scala-free-monads">http://skillsmatter.com/podcast/scala/stackless-scala-free-monads</a>
论文原稿: <a href="http://days2012.scala-lang.org/sites/days2012/files/bjarnason_trampolines.pdf">http://days2012.scala-lang.org/sites/days2012/files/bjarnason_trampolines.pdf</a>
</p>
</div>
</div>

<div id="outline-container-org81aaf48" class="outline-2">
<h2 id="org81aaf48"><span class="section-number-2">3</span> Body 正文</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-org1800b66" class="outline-3">
<h3 id="org1800b66"><span class="section-number-3">3.1</span> Abstract 摘要</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Scala 编译器的尾调用优化 (Tail Call Elimination, TCE) 仅限于自递归方法 (Self-Recursive Methods) 而不是所有的尾调用. 这很容易使得那些由小函数组合而成的函数造成堆栈溢出. 拥有一个通用的尾调用优化方法非常有益于 Scala 语言, 尤其是有益于 Scala 的函数式编程. 针对那些本不支持尾调用优化的语言, Trampolining 是一个可以用于解决尾调用优化问题的常用方法. 本文引入 Trampolining 技术, 以将其推广为一个对任何方法调用(甚至是非尾部调用)的优化技术. 该技术能够完全的消除 Scala 程序对调用堆栈的使用.
</p>
</div>
</div>

<div id="outline-container-org766ed74" class="outline-3">
<h3 id="org766ed74"><span class="section-number-3">3.2</span> Introduction 介绍</h3>
<div class="outline-text-3" id="text-3-2">
<p>
调用堆栈是虚拟机的有限资源, 稍微有点经验的 Scala 程序员应该都遇见过一些看上去很正常的函数用尽了调用堆栈后使得程序崩溃并抛出 <code>StackOverflowError</code> 的错误.
考虑一个实用的例子, 在遍历一个 <code>List</code> 的同时维护一些状态. 我们采用 <code>State</code> 数据结构来表征一个简单的状态机的变换.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, +<span style="color: #bbdaff;">A</span>](runS<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span> <span style="color: #d1f1a9;">=&gt;</span> (<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">S</span>)) {
  <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">map</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>) <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>] { s <span style="color: #d1f1a9;">=&gt;</span> {
    <span style="color: #d1f1a9;">val</span> (<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">s1</span>) <span style="color: #d1f1a9;">=</span> runS(s)
    (f(a), s1)
  }}

  <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">flatMap</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>] { s <span style="color: #d1f1a9;">=&gt;</span> {
    <span style="color: #d1f1a9;">val</span> (<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">s1</span>) <span style="color: #d1f1a9;">=</span> runS(s)
    f(a).runS(s1)
  }}
}
</pre>
</div>

<p>
函数 <code>runS</code> 以一个类型为 <code>S</code> 的状态作为输入, 返回一个类型为 <code>A</code> 的值以及一个新的状态. 而 <code>map</code> 和 <code>flatMap</code> 方法允许通过 for-comprehension 以一种命令式的代码方式将状态变换组合在一起, 如:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">getState</span>[<span style="color: #bbdaff;">S</span>]<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">S</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>(s <span style="color: #d1f1a9;">=&gt;</span> (s, s))

<span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">setState</span>[<span style="color: #bbdaff;">S</span>](s<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">Unit</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>(<span style="color: #d1f1a9;">_</span> <span style="color: #d1f1a9;">=&gt;</span> ((), s))

<span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">pureState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>](a<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>(s <span style="color: #d1f1a9;">=&gt;</span> (a, s))
</pre>
</div>

<p>
注意到 <code>pureState</code> 和 <code>flatMap</code> 两个方法使得 <code>State</code> 成为一个 Monad.
</p>

<p>
作为一个简单的例子, 我们用 <code>State</code> 来实现对一个 <code>List</code> 中的元素编号. 这并不见得是 <code>State</code> 的一个常见用例, 仅仅因为这能够简单的诠释上文所说的堆栈溢出问题.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">zipIndex</span>[<span style="color: #bbdaff;">A</span>](as<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[(<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">A</span>)] <span style="color: #d1f1a9;">=</span> as.foldLeft(pureState[<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">List</span>[(<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">A</span>)]](<span style="color: #bbdaff;">Nil</span>)) { (acc, a) <span style="color: #d1f1a9;">=&gt;</span>
  <span style="color: #d1f1a9;">for</span> {
    xs <span style="color: #d1f1a9;">&lt;-</span> acc
    n <span style="color: #d1f1a9;">&lt;-</span> getState[<span style="color: #bbdaff;">Int</span>]
    <span style="color: #d1f1a9;">_</span> <span style="color: #d1f1a9;">&lt;-</span> setState[<span style="color: #bbdaff;">Int</span>](n + <span style="color: #bbdaff;">1</span>)
  } <span style="color: #d1f1a9;">yield</span> (n, a) :: xs
}.runS(<span style="color: #bbdaff;">0</span>)._1.reverse
</pre>
</div>

<blockquote>
<p>
译者注: 对于 <code>State</code> 的 <code>flatMap</code> 方法, 每次调用都会在堆中产生一个新的 <code>State.class</code> 类型实例及其 <code>runS</code> 方法的函数类型 <code>State.1.class</code> 的实例. (<a href="http://blog.thegodcode.net/post/239967776/a-look-at-how-scala-compiles-to-java">A Look at How Scala Compiles to Java</a>)
</p>
</blockquote>

<p>
我们使用一个 <code>foldLeft</code> 来强调对 <code>list</code> 的遍历是一个尾递归的调用. 这个函数以一个空的 <code>list</code> 为起点, 不断在列表的头部添加元素, 所以与原 <code>list</code> 顺序相反. 而 <code>state</code> 是一个从零开始每步递增的整数, 所有的 <code>state</code> 的生成都发生在反转结果之前.
</p>

<p>
但是如果用一个元素数量超过虚拟机调用堆栈大小的 <code>list</code> 作为参数, <code>State.flatMap</code> 方法会抛出 <code>StackOverflowError</code> 的错误. 发生错误的原因是最终的 <code>state</code> 本质上是一个大函数, 由与 <code>list</code> 大小成正比的多个函数组合而成. 尽管它让我们觉得这是一个离散的一系列步骤, 但每个步骤使用了一种无法另编译器优化的方式去调用下一个步骤.
</p>

<p>
这种情况极大的限制了 Scala 的函数式编程特性. 而这篇论文就是来探讨解决方案的:
</p>
<ul class="org-ul">
<li>第三部分将探讨熟知的 Trampolining 技术. 在一个 Trampolined 的程序中, 我们不再让每个步骤直接去调用另一个步骤, 而采用一种 Trampoline 控制循环来暂缓下一步骤的发生. 这使得我们可以用堆去代替调用栈.</li>
<li>之后(在第四部分), 我们会将这种方法扩展为一个 Monad, 使得所有的调用都可以被转化为可依次消除的尾递归调用.</li>
<li>在实现这种 monad 时, 如果实现不当, 依然会导致在一些场景堆栈溢出的错误. 在 4.3 节, 我们将探讨这些场景以及如何消除这些问题.</li>
<li>Trampolined 程序可以是多层嵌套的来提供 cooperative coroutines, 我们将在第五部分探讨.</li>
<li>在第六部分, 我们将 Trampolines 推广为 Free Monad, 一种极为通用的递归数据结构. 通过分析操作这种结构的部分函数, 利用 Trampoline 的方法来解决 Free Monad 的堆栈问题.</li>
</ul>
</div>
</div>

<div id="outline-container-org4d35178" class="outline-3">
<h3 id="org4d35178"><span class="section-number-3">3.3</span> 背景: Scala 的尾调用优化</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Scala 的编译器能够对一种叫做自调用尾递归 (Self-recursive Call) 的代码进行优化. 例如, 下面实例代码中对 list 的 <b>左折</b> 操作可以被编译器优化为一个使用固定栈空间的函数:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">foldl</span>[<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>](as<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>], b<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">B</span>, f<span style="color: #d1f1a9;">:</span> (<span style="color: #bbdaff;">B</span>, <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">B</span> <span style="color: #d1f1a9;">=</span>
  as <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> b
    <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=&gt;</span> foldl(xs, f(b, x), f)
  }
</pre>
</div>

<p>
当编译器发现一个函数在尾部调用了自己, 并且 <b>该函数不能被重载 (例如, 使用 <code>private</code> 或 <code>final</code> 关键字声明)</b>, 则该函数的自调用会被编译替换为一个简单的跳转 (Jump). 这就相当于将该递归写成一个这循环:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">foldl</span>[<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>](as<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>], b<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">B</span>, f<span style="color: #d1f1a9;">:</span> (<span style="color: #bbdaff;">B</span>, <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">B</span> <span style="color: #d1f1a9;">=</span> {
  <span style="color: #d1f1a9;">var</span> <span style="color: #ff9da4; font-weight: bold;">z</span> <span style="color: #d1f1a9;">=</span> b
  <span style="color: #d1f1a9;">var</span> <span style="color: #ff9da4; font-weight: bold;">az</span> <span style="color: #d1f1a9;">=</span> as
  <span style="color: #d1f1a9;">while</span> (<span style="color: #bbdaff;">true</span>) {
    az <span style="color: #d1f1a9;">match</span> {
      <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #d1f1a9;">return</span> z
      <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=&gt;</span>
        z <span style="color: #d1f1a9;">=</span> f(b, x)
        az <span style="color: #d1f1a9;">=</span> xs
    }
  }
}
</pre>
</div>

<p>
除了跳转比方法调用更高效这个优势外, 这种优化使得无需使用任何调用栈.
但是,用跳转替换一个普通的尾调用就没有自递归调用优化那么简单了. 目前, JVM 只允许本地跳转, 所以根本没法从一个方法尾部直接跳转至另一个方法.例如, 一个相互跳转的递归是不能被编译器优化的, 即便它的调用在方法的尾部.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">even</span>[<span style="color: #bbdaff;">A</span>](ns<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Boolean</span> <span style="color: #d1f1a9;">=</span> ns <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">true</span>
  <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=&gt;</span> odd(xs)
}

<span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">odd</span>[<span style="color: #bbdaff;">A</span>](ns<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Boolean</span> <span style="color: #d1f1a9;">=</span> ns <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">false</span>
  <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=</span> even(xs)
}
</pre>
</div>

<p>
这两个方法会在参数长度大于堆栈长度时引发堆栈溢出.
</p>

<p>
尽管 JVM 很可能会在未来改进这点, 但也并不是一件容易的事, 并且有可能没有想象中那么有用. 比如说, JVM 的调用模型需要把每个线程的执行状态都保存在线程的调用堆栈里. 另外, 异常处理也是通过将异常压栈后将堆栈暴露给程序进行检查的. 事实上, JVM 的安全模型也是基于检查每个调用栈帧 (Stack Frame) 的权限来实现的. 而这又与子类, 动态分配策略,
即时编译器偶合在一起, 使得 Scala 编译器的尾调用优化难以实现.
</p>

<p>
不过还好, 我们可以回避所有这些问题, 通过一种简单的数据结构来用堆空间来代替栈空间.
</p>
</div>
</div>

<div id="outline-container-org532d2f1" class="outline-3">
<h3 id="org532d2f1"><span class="section-number-3">3.4</span> Trampolines: 以堆换栈</h3>
<div class="outline-text-3" id="text-3-4">
<p>
我们从一个非常简单的 Trampoline 数据类型来说明. 下例与 <code>scala.util.control.TailCalls.TailRec</code> 包中的 Trampoline 从原理上是完全相同的, 尽管实现的方式不同.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">sealed</span> <span style="color: #d1f1a9;">trait</span> <span style="color: #bbdaff;">Trampoline</span>[+<span style="color: #bbdaff;">A</span>] {
  <span style="color: #ebbbff;">final</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">runT</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">this</span> <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> k().runT
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">v</span>) <span style="color: #d1f1a9;">=&gt;</span> v
  }
}

<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">More</span>[+<span style="color: #bbdaff;">A</span>](k<span style="color: #d1f1a9;">:</span> () <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>])
    <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>]

<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">Done</span>[+<span style="color: #bbdaff;">A</span>](v<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>)
    <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
Trampoline 将计算分解为多个步骤, 每个步骤可以有两种形式. <code>Done</code> 包含一个用于返回的值 <code>v</code>, 表示后续再无其他步骤. <code>More</code> 则包含一个生成后续步骤的函数 <code>k</code>. 而 <code>runT</code> 方法则是一个简单的尾递归, 用于执行所有的步骤. 它被定义为 <code>final</code> 以便让 Scala 编译器进行优化.
这就可以解决上文提到的互相跳转的尾调用递归问题. 我们只需要机械的将所有类型为 <code>T</code> 的返回值替换为 <code>Trampoline[T]</code> 就行了. 具体如下:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">even</span>[<span style="color: #bbdaff;">A</span>](ns<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">Boolean</span>] <span style="color: #d1f1a9;">=</span> ns <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #bbdaff;">true</span>)
  <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> odd(xs))
}

<span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">odd</span>[<span style="color: #bbdaff;">A</span>](ns<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">Boolean</span>] <span style="color: #d1f1a9;">=</span> ns <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Nil</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #bbdaff;">false</span>)
  <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #bbdaff;">::</span> <span style="color: #ffeead;">xs</span> <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> even(xs))
}
</pre>
</div>

<p>
我们从原来的直接递归调用, 变成使其返回一个表示下一个步骤的 <code>Trampoline</code>, 然后可以通过调用可以被优化的方法 <code>runT</code> 来递归执行. 这样, 无论输入的 <code>List</code> 有多长, 上面的代码也不会再引发堆栈溢出.
</p>
</div>
</div>

<div id="outline-container-org19749c8" class="outline-3">
<h3 id="org19749c8"><span class="section-number-3">3.5</span> 把所有调用都变为尾调用</h3>
<div class="outline-text-3" id="text-3-5">
<p>
让我们看看如何使用 Trampoline 技术来解决论文一开始提出的 State 遍历 list 的 堆栈溢出问题. 首先, 我们需要改写 State 的行为来返回可供尾递归的 Trampoline 类型.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, +<span style="color: #bbdaff;">A</span>](runS<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[(<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">S</span>)])
</pre>
</div>

<p>
我们现在该如何实现组合 State 的 flatMap 呢? 先试试这样:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">flatMap</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>] { s <span style="color: #d1f1a9;">=&gt;</span>
  <span style="color: #bbdaff;">More</span>[(<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>)] { () <span style="color: #d1f1a9;">=&gt;</span>
    <span style="color: #d1f1a9;">val</span> (<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">s1</span>) <span style="color: #d1f1a9;">=</span> runS(s).runT
    <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> f(a).runS(s1))
  }
}
</pre>
</div>

<p>
但这样写会很低效. 而且例一中的 <code>zipIndex</code> 仍然可能会堆栈溢出, 甚至对于更小的 list. 问题出在 <code>runT</code> 的调用没有出现在尾部, 所以它并不能被封装在 <code>Trampoline</code> 内部, 也不能用 Trampoline 来优化.
</p>
</div>

<div id="outline-container-orgd46c916" class="outline-4">
<h4 id="orgd46c916"><span class="section-number-4">3.5.1</span> 用一个 Trampoline Monad ?</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
现在我们要用一个 Monadic 的 <code>Trampoline</code> 来解决该问题。它已经有了 <code>unit</code> 操作<sup>1</sup>，定义在构造函数中。因此，只需要定义 Monadic 的 <code>bind</code> 操作，也就是 <code>flatMap</code> 方法, 即可. 让我们直接给 <code>Trampoline</code> 添加一个 <code>flatMap</code> 方法，如此一来，就可以将 <code>State.flatMap</code> 改写为：
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">flatMap</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">=</span>
  <span style="color: #bbdaff;">State</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>](s <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> runS(s) flatMap {
    <span style="color: #d1f1a9;">case</span> (<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">s1</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> f(a) runS s1)
  }))
</pre>
</div>

<blockquote>
<p>
.<sup>1</sup> 对于任意类型 <code>A</code>, <code>Monad</code> <code>M</code> 的 <code>unit</code> 函数定义为 <code>A =&gt; M[A]</code>. 之所以叫做 <code>unit</code> 是因为它是 <code>flatMap</code> 操作的 <code>幺元</code>.
</p>
</blockquote>

<p>
这显然有所改进. 它把问题转移到 <code>Trampoline</code> 的 <code>flatMap</code> 方法中, 因此我们可以这样试着实现：
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">flatMap</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">=</span>
  <span style="color: #bbdaff;">More</span>[<span style="color: #bbdaff;">B</span>](() <span style="color: #d1f1a9;">=&gt;</span> f(runT))
</pre>
</div>

<p>
但这不是我们想要的. <code>runT</code> 依然不在调用的尾部. 看来无论我们怎么实现 <code>Trampoline</code> 的 <code>flatMap</code>, 都不可能不消耗额外的栈空间.
</p>
</div>
</div>

<div id="outline-container-org9bfa9f5" class="outline-4">
<h4 id="org9bfa9f5"><span class="section-number-4">3.5.2</span> 正确的构建 Monad</h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
解决该问题的方法是为 <code>Trampoline</code> 数据类型增加一个类型构造器，并将 <code>flatMap</code> 方法的调用改为对构造器的调用:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">FlatMap</span>[<span style="color: #bbdaff;">A</span>, +<span style="color: #bbdaff;">B</span>](
  sub<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>],
  k<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>]
</pre>
</div>

<p>
<code>Trampoline</code> 的这种形式可以看作是对子程序 <code>sub</code> 的调用，其结果会被传入 <code>continuation</code> <code>k</code>.
这时候, <code>Trampoline</code> <code>trait</code> 的 <code>runT</code> 就需要考虑这个新的构造器. 为了简单说明, 让我们把执行下一步与执行所有步分开：
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">final</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">resume</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Either</span>[() <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>], <span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">this</span> <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">v</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Right</span>(v)
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Left</span>(k)
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">FlatMap</span>(<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">f</span>) <span style="color: #d1f1a9;">=&gt;</span> a <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">v</span>) <span style="color: #d1f1a9;">=&gt;</span> f(v).resume
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Left</span>(() <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">FlatMap</span>(k(), f))
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">FlatMap</span>(<span style="color: #ffeead;">b</span>, <span style="color: #ffeead;">g</span>) <span style="color: #d1f1a9;">=&gt;</span> (<span style="color: #bbdaff;">FlatMap</span>(b, (x<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Any</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">FlatMap</span>(g(x), f))<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>]).resume
  }
}

<span style="color: #ebbbff;">final</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">runT</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=</span> resume <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>) <span style="color: #d1f1a9;">=&gt;</span> a
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> k().runT
}
</pre>
</div>

<p>
<code>resume</code> 方法利用模式匹配来处理 <code>Trampoline</code>, 或者返回一个结果(即 <code>Right</code>), 或者返回一个 <code>Function0</code> 来表明下一步的操作(即 <code>Left</code>).
这里处理 <code>FlatMap</code> 这种情况的方式微秒而重要. 如果子程序 <code>a</code> 是 <code>Done</code>, 我们会直接执行 <code>continuation</code>. 如果其被包裹在 <code>More</code> 中, 我们向前执行一步(译者: 即执行 <code>More</code> 中的函数), 并对其执行 <code>FlatMap</code> 操作. 如果子程序包含另一个子程序, 也就是一个内嵌的左结合的 <code>FlatMap</code> 如下:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #bbdaff;">FlatMap</span>(<span style="color: #bbdaff;">FlatMap</span>(b, g), f)
</pre>
</div>

<p>
这一步非常关键, 我们需要保证不引入新的栈帧. 技巧是利用结合律将其变换到右边:
(译者: 注意 <code>Trampoline</code> <code>Monad</code> 满足结合律,
因此 <code>(b FlatMap g) FlatMap f = b FlatMap (x =&gt; g(x) FlatMap f)</code>)
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #bbdaff;">FlatMap</span>(b, x <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">FlatMap</span>(g(x), f))
</pre>
</div>

<p>
这样一来, 在下一个迭代时就会对 <code>b</code> 进行模式匹配, 这样就能够在尾部继续调用 <code>resume</code>.
由于这次 <code>resume</code> 调用是在 <code>FlatMap</code> 上的, 我们必须显示的将当前的对象转换为 <code>Trampoline</code>, 这样编译器才能明白这其实是一次尾递归调用<sup>2</sup>. 不用担心, 我们会在 4.3 节去掉该转换.
</p>

<p>
同时需要注意的是, 内嵌的 <code>FlatMap</code> 构造器中丢失了一些类型信息. 在 <code>FlatMap(FlatMap(b, g), f)</code> 形式中, <code>b</code> 的类型无从得知, 所以只能在转换右结合时将其视为 <code>Any</code>. 这其实非常安全, 因为左结合时的嵌套结构的类型是正确的.
p
通过结合律转换利用到了 <code>Monad</code> 的规则. <code>Trampoline</code> 是一个 <code>Monad</code>, 而 <code>Monad</code> 一定是满足结合律的. 因此, 右结合方式一定等价于左结合的.
</p>

<blockquote>
<p>
译者注:
<code>Trampoline</code> 的三个实例代表了不同的使用场景: <code>Done</code> 表明了下一步计算会取出其值, 用于递归中的返回. <code>More</code> 表明了下一步计算的递归特性, 一般用于递归调用. <code>FlatMap</code> 中包含两个值, 左侧的子程序表明了下一步计算的类型, 右侧的函数表明了在下一步计算后需要做的事, 因此可用于非尾递归的后续操作.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgc3c3b75" class="outline-4">
<h4 id="orgc3c3b75"><span class="section-number-4">3.5.3</span> 一个易错的问题</h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
这里还有一个边缘情况需要考虑. <code>resume</code> 函数依然有可能造成栈溢出. 倘若 <code>FlatMap</code> 左侧的堆叠层次高出了调用栈的高度, <code>f(v)</code> 的调用会导致 <code>g(x)</code> 调用, 然后会导致里层的函数调用, 等等. 这可以通过在一开始就禁止左结合的内嵌的构造来避免. 我们将 <code>FlatMap</code> 构造器变为 <code>private</code>, 并通过暴露 <code>Trampoline</code> 的 <code>flatMap</code> 方法来代替它, 这样就能总是用右结合的结构来改写:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">flatMap</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">this</span> <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">FlatMap</span>(<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">g</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">FlatMap</span>(a, (x<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">=&gt;</span> g(a) flatMap f)
  <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">x</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">FlatMap</span>(x, f)
}
</pre>
</div>

<p>
同时, 必须同时避免通过 <code>resume</code> 方法来构造这种结构, 我们可以将其中的 <code>FlatMap</code> 构造改为对 <code>flatMap</code> 的调用:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">FlatMap</span>(<span style="color: #ffeead;">a</span>, <span style="color: #ffeead;">f</span>) <span style="color: #d1f1a9;">=&gt;</span> a <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">v</span>) <span style="color: #d1f1a9;">=&gt;</span> f(v).resume
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Left</span>(() <span style="color: #d1f1a9;">=&gt;</span> k() flatMap f)
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">FlatMap</span>(<span style="color: #ffeead;">b</span>, <span style="color: #ffeead;">g</span>) <span style="color: #d1f1a9;">=&gt;</span>
    b.flatMap((x<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Any</span>) <span style="color: #d1f1a9;">=&gt;</span> g(x) flatMap f).resume
}
</pre>
</div>

<p>
最终, 为了能够在 Scala 的 for-comprehension 表达式中使用 <code>Trampoline</code> monad, 只需要用 <code>flatMap</code> 定义一个 <code>map</code> 方法就行了:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">map</span>[<span style="color: #bbdaff;">B</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>] <span style="color: #d1f1a9;">=</span>
  flatMap(a <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(f(a)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3d2b55b" class="outline-3">
<h3 id="org3d2b55b"><span class="section-number-3">3.6</span> 无栈 Scala</h3>
<div class="outline-text-3" id="text-3-6">
<p>
通过使用 <code>Trampoline</code> 化的 <code>State</code> monad, 对任何大小的输入 <code>list</code>, 现在运行之前看到的 <code>zipIndex</code> 方法不会在引发堆栈溢出的异常了.
这里介绍的 <code>Trampoline</code> 是 Scala 中清除栈帧的一种通用手段. 我们可以用它来重写任何程序而不再需要栈空间了. 考虑一个具有如下形式的程序:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">val</span> <span style="color: #ffeead;">x</span> <span style="color: #d1f1a9;">=</span> f()
<span style="color: #d1f1a9;">val</span> <span style="color: #ffeead;">y</span> <span style="color: #d1f1a9;">=</span> g(x)
h(y)
</pre>
</div>

<p>
可以非常轻松的这样重写:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">for</span> {
  x <span style="color: #d1f1a9;">&lt;-</span> f()
  y <span style="color: #d1f1a9;">&lt;-</span> g(x)
  z <span style="color: #d1f1a9;">&lt;-</span> h(y)
} <span style="color: #d1f1a9;">yield</span> z
</pre>
</div>

<p>
当然, 需要定义如下的隐式转换:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">implicit</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">step</span>[<span style="color: #bbdaff;">A</span>](a<span style="color: #d1f1a9;">:</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">A</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span>
  <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(a))
</pre>
</div>

<p>
唯一不太适合用 <code>step</code> 转换的是(非偶然地)自递归调用. 这非常容易察觉, 当这种情况, 我们可以显示的调用 <code>More</code> 构造器, 例如下面的计算第 <code>n</code> 个斐波那契数的递归函数:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">fib</span>(n<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Int</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">Int</span>] <span style="color: #d1f1a9;">=</span>
  <span style="color: #d1f1a9;">if</span>(n &lt;= <span style="color: #bbdaff;">1</span>) <span style="color: #bbdaff;">Done</span>(n) <span style="color: #d1f1a9;">else</span> <span style="color: #d1f1a9;">for</span> {
    x <span style="color: #d1f1a9;">&lt;-</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> fib(n-1))
    y <span style="color: #d1f1a9;">&lt;-</span> <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> fib(n-2))
  } <span style="color: #d1f1a9;">yield</span> x + y
</pre>
</div>

<p>
由于这种转换是完全机械化的, 可能有人会写一个编译器插件或者扩展 Scala 的编译期将所有程序转换成这样.
</p>
</div>
</div>

<div id="outline-container-org198aa06" class="outline-3">
<h3 id="org198aa06"><span class="section-number-3">3.7</span> 多任务</h3>
<div class="outline-text-3" id="text-3-7">
<p>
我们已经看到如何使用 <code>flatMap</code> 序列化的组合 <code>Trampoline</code>. 但其实可以通过交叉计算来并行的组合它们:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">zip</span>[<span style="color: #bbdaff;">B</span>](b<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">B</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[(<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>)] <span style="color: #d1f1a9;">=</span>
  (<span style="color: #d1f1a9;">this</span>.resume, b.resume) <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Right</span>(<span style="color: #bbdaff;">B</span>)) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>((a, b))
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span>
      <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> a() zip b())
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span>
      <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> a() zip <span style="color: #bbdaff;">Done</span>(b))
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span>
      <span style="color: #bbdaff;">More</span>(() <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(a) zip b())
  }
</pre>
</div>

<p>
为了验证, 我们引入控制台打印:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">val</span> <span style="color: #ffeead;">hello</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Trampoline</span>[<span style="color: #bbdaff;">Unit</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">for</span> {
  <span style="color: #d1f1a9;">_</span> <span style="color: #d1f1a9;">&lt;-</span> print(<span style="color: #99ffff;">"Hello, "</span>)
  <span style="color: #d1f1a9;">_</span> <span style="color: #d1f1a9;">&lt;-</span> println(<span style="color: #99ffff;">"World!"</span>)
} <span style="color: #d1f1a9;">yield</span> ()
</pre>
</div>

<p>
将其与自身交错执行, 然后观察结果:
</p>

<div class="org-src-container">
<pre class="src src-scala">(hello zip hello).runT
<span style="color: #7285b7; font-style: italic;">// </span><span style="color: #7285b7; font-style: italic;">Hello, Hello, World!</span>
<span style="color: #7285b7; font-style: italic;">// </span><span style="color: #7285b7; font-style: italic;">World!</span>
</pre>
</div>

<p>
尽管这是单线程的并行计算, 但很容易扩展到多线程的分布式计算. 对于一组待执行的 <code>trampoline</code>, 任何不是 <code>Done</code> 的 <code>resume</code> 任务都可以在任何线程执行.
</p>

<p>
可以将其推广到一个完全对称的协同程序. 我们会在下一节讨论.
</p>
</div>
</div>

<div id="outline-container-org1617388" class="outline-3">
<h3 id="org1617388"><span class="section-number-3">3.8</span> Free Monads: Trampoline 的推广</h3>
<div class="outline-text-3" id="text-3-8">
<p>
我们可以将 <code>Trampoline</code> 看作事一个能通过 <code>Function0</code> 挂起并之后执行的协同程序. 那么它就不再是唯一一种有此性质的类型构造器了, 如果将该行为抽象, 我们就能获得如下的类型:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">sealed</span> <span style="color: #d1f1a9;">trait</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>[+<span style="color: #d1f1a9;">_</span>], +<span style="color: #bbdaff;">A</span>] {
  <span style="color: #ebbbff;">private</span> <span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">FlatMap</span>[<span style="color: #bbdaff;">S</span>[+<span style="color: #d1f1a9;">_</span>], <span style="color: #bbdaff;">A</span>, +<span style="color: #bbdaff;">B</span>](
    a<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>],
    f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>]) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>]
}

<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">Done</span>[<span style="color: #bbdaff;">S</span>[+<span style="color: #d1f1a9;">_</span>], +<span style="color: #bbdaff;">A</span>](a<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]

<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">More</span>[<span style="color: #bbdaff;">S</span>[+<span style="color: #d1f1a9;">_</span>], +<span style="color: #bbdaff;">A</span>](k<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>[<span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]]) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<blockquote>
<p>
译者注: S 是 Function0 的推广. S 具有能够挂起计算的能力.
</p>
</blockquote>

<p>
那么, <code>Trampoline</code> 可以如下定义:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">Trampoline</span>[+<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">Function0</span>, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
就像 <code>Done</code> 和 <code>FlatMap</code> 数据构造器一样, <code>Free[S, A]</code> 是任意协变的 <code>Functor</code> S 的一种 Monad. 从范畴论角度来看, 它正是该 <code>Functor</code> 生成的 <code>Free Monad</code> [4].
S 必须是一个 <code>Functor</code> 即必须存在 Functor[S]<sup>3</sup>:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">trait</span> <span style="color: #bbdaff;">Functor</span>[<span style="color: #bbdaff;">F</span>[<span style="color: #d1f1a9;">_</span>]] {
  <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">map</span>[<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>](m<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">F</span>[<span style="color: #bbdaff;">A</span>])(f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">F</span>[<span style="color: #bbdaff;">B</span>]
}
</pre>
</div>

<p>
对 <code>Function0</code> 来说是显而易见的:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">implicit</span> <span style="color: #d1f1a9;">val</span> <span style="color: #ffeead;">f0Functor</span> <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">new</span> <span style="color: #bbdaff;">Functor</span>[<span style="color: #bbdaff;">Function0</span>] {
  <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">map</span>[<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>](a<span style="color: #d1f1a9;">:</span> () <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">A</span>)(f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>) <span style="color: #d1f1a9;">=</span> () <span style="color: #d1f1a9;">=&gt;</span> f(a())
}
</pre>
</div>
</div>

<div id="outline-container-org69f3e7d" class="outline-4">
<h4 id="org69f3e7d"><span class="section-number-4">3.8.1</span> Free Monad 的函数</h4>
<div class="outline-text-4" id="text-3-8-1">
<p>
为证实 Free Monad 的功效, 我们需要将之前为 <code>Trampoline</code> 定义的函数进行推广. 例如, 以下是 <code>resume</code> 的推广:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">final</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">resume</span>(<span style="color: #ebbbff;">implicit</span> <span style="color: #bbdaff;">S</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Functor</span>[<span style="color: #bbdaff;">S</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Either</span>[<span style="color: #bbdaff;">S</span>[<span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]], <span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span>
  <span style="color: #d1f1a9;">this</span> <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">a</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Right</span>(a)
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Left</span>(k)
    <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">a</span> <span style="color: #bbdaff;">FlatMap</span> <span style="color: #ffeead;">f</span> <span style="color: #d1f1a9;">=&gt;</span> a <span style="color: #d1f1a9;">match</span> {
      <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Done</span>(<span style="color: #ffeead;">a</span>) <span style="color: #d1f1a9;">=&gt;</span> f(a).resume
      <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">More</span>(<span style="color: #ffeead;">k</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Left</span>(<span style="color: #bbdaff;">S</span>.map(k)(<span style="color: #d1f1a9;">_</span> flatMap f))
      <span style="color: #d1f1a9;">case</span> <span style="color: #ffeead;">b</span> <span style="color: #bbdaff;">FlatMap</span> <span style="color: #ffeead;">g</span> <span style="color: #d1f1a9;">=&gt;</span> b.flatMap((x<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Any</span>) <span style="color: #d1f1a9;">=&gt;</span> g(x) flatMap f).resume
    }
  }
</pre>
</div>

<p>
注意到该定义与之前 <code>Trampoline</code> 的 <code>resume</code> 如出一辙. 有所不同的只是类型签名, 隐式的 <code>Functor</code> 参数, 以及我们将显式的 <code>Function0</code> 构造改为了 <code>Functor</code> 的 <code>map</code> 方法调用. 这也适用于其它函数, 如 <code>zip</code>, <code>map</code>, 和 <code>flatMap</code> [10]. 以下是 <code>zip</code> 的定义:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">zip</span>[<span style="color: #bbdaff;">B</span>](b<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">B</span>])(<span style="color: #ebbbff;">implicit</span> <span style="color: #bbdaff;">S</span><span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Functor</span>[<span style="color: #bbdaff;">S</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">S</span>, (<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>)] <span style="color: #d1f1a9;">=</span>
  (<span style="color: #d1f1a9;">this</span>.resume, b.resume) <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Right</span>(<span style="color: #bbdaff;">B</span>)) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>((a, b))
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">S</span>.map(a)(x <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">S</span>.map(b)(y <span style="color: #d1f1a9;">=&gt;</span> x zip y))))
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">S</span>.map(a)(x <span style="color: #d1f1a9;">=&gt;</span> x zip <span style="color: #bbdaff;">Done</span>(b))
    <span style="color: #d1f1a9;">case</span> (<span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>), <span style="color: #bbdaff;">Left</span>(<span style="color: #ffeead;">b</span>)) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">S</span>.map(b)(y <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(a) zip y)
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-org7656f91" class="outline-4">
<h4 id="org7656f91"><span class="section-number-4">3.8.2</span> 普通数据类型到 Free Monad</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
粗略的来看, 我们可以将 <code>Free[S, A]</code> 看作事任何以某种 <code>Functor</code> S 作为分支节点并以某种数据类型 A 作为叶子节点的计算. 为证明这一点, 考虑一个普通的决策树. 它是一个 <code>Free Monad</code>, 其 <code>Functor</code> 将每个分支节点的计算分为两部分:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">Pair</span>[+<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> (<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">A</span>)
<span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">BinTree</span>[+<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">Pair</span>, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
<code>BinTree[A]</code> 的 <code>Done</code> 的情况指的是包含一个类型为 A 的值的叶子节点. 其 <code>More</code> 则是一个包含两个类型为 <code>BinTree[A]</code> 的分支节点. 我们的 <code>Free Monad</code> (即 FlatMap 的情况) 就是对任意的节点, 给予一个树生成算法, 再将生成的树替换原有节点. 由于它是 <code>Free</code> 的实例, 因此 <code>Trampline</code> 的特性使得我们可以在恒定的时间和栈空间进行操作.
</p>

<p>
为了得到一棵能够给定任意分支数量的树, 我们可以使用 <code>List</code> Functor:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">Tree</span>[+<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Free</span>[<span style="color: #bbdaff;">List</span>, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
事实上, <code>List</code> 本身就可以表示为 <code>Free</code> _<sup>4</sup> 的应用:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Free</span>[({<span style="color: #d1f1a9;">type</span> &#955;[+&#945;] <span style="color: #d1f1a9;">=</span> (<span style="color: #bbdaff;">A</span>, &#945;)}<span style="color: #d1f1a9;">#</span>&#955;), <span style="color: #bbdaff;">Unit</span>]
</pre>
</div>

<p>
在这种表示中, 一个 <code>List[A]</code> 是一个协同程序, 它每次 <code>resume</code> 可以产生一个类型为 A 的值, 而 <code>Unit</code> 则表示当前为空. 这里的 <code>bind</code> 并不是真正 <code>List</code> 的 <code>flatMap</code> (也就是由一个新生成 <code>List</code> 替代每个当前元素), 而是将两个 <code>List</code> 首尾相连<sup>5</sup>. 同样, 由于是 <code>Free</code> 的实例, 操作均在恒定的时间和栈空间中.
</p>

<p>
这里所给的 <code>List</code> 的类型参数是一个逆变的, 但可以改为协变. 这可以作为一个小练习.
</p>
</div>
</div>

<div id="outline-container-org188a5d4" class="outline-4">
<h4 id="org188a5d4"><span class="section-number-4">3.8.3</span> 一个 Free 的 State Monad</h4>
<div class="outline-text-4" id="text-3-8-3">
<p>
尽管本文所举的 <code>Free Monad</code> 的例子非常简单, 用来挂起的 <code>Functor</code> 可以是非常复杂的. 它可以以任意的组合方式来输出或等待输入. 我们可以把 <code>State</code> 作为一种小型语言, 这是状态的 <code>set</code> 和 <code>put</code> 定义:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">sealed</span> <span style="color: #d1f1a9;">trait</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, +<span style="color: #bbdaff;">A</span>]
<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">Get</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>](f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]
<span style="color: #d1f1a9;">case</span> <span style="color: #d1f1a9;">class</span> <span style="color: #bbdaff;">Put</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>](s<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>, a<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>) <span style="color: #d1f1a9;">extends</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
在 <code>Get</code> 的构造器中, <code>f</code> 是一个接收当前状态值的函数. 而在 <code>Put</code> 构造器中, <code>s</code> 是一个新的状态, a 是计算的剩余部分 (可能用来对状态做一些事情).
</p>

<p>
我们要指明当前的数据类型是一个 <code>Functor</code>:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #ebbbff;">implicit</span> <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">statefFun</span>[<span style="color: #bbdaff;">S</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #d1f1a9;">new</span> <span style="color: #bbdaff;">Functor</span>[({<span style="color: #d1f1a9;">type</span> &#955;[+&#945;] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, &#945;)})<span style="color: #d1f1a9;">#</span>&#955;] {
  <span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">map</span>[<span style="color: #bbdaff;">A</span>, <span style="color: #bbdaff;">B</span>](m<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>])(f<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">B</span>) <span style="color: #d1f1a9;">=</span> m <span style="color: #d1f1a9;">match</span> {
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Get</span>(<span style="color: #ffeead;">g</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Get</span>((s<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>) <span style="color: #d1f1a9;">=&gt;</span> f(g(s)))
    <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Put</span>(<span style="color: #ffeead;">s</span>, <span style="color: #ffeead;">a</span>) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Put</span>(s, f(a))
  }
}
</pre>
</div>

<p>
我们可以直接用 <code>StateF</code> <code>Functor</code> 来生成一个类 <code>State</code> 的 <code>Monad</code>:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">type</span> <span style="color: #bbdaff;">FreeState</span>[<span style="color: #bbdaff;">S</span>, +<span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Free</span>[({<span style="color: #d1f1a9;">type</span> &#955;[+&#945;] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">StateF</span>[<span style="color: #bbdaff;">S</span>, &#945;)})<span style="color: #d1f1a9;">#</span>&#955;, <span style="color: #bbdaff;">A</span>]
</pre>
</div>

<p>
第一部分的 <code>pureState</code> 组合子可以由 <code>Free Monad</code> 的 <code>Done</code> 构造器生成:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">pureState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>](a<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">FreeState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">Done</span>(a)
</pre>
</div>

<p>
另外的获取和设置状态的方法也可以简单定义:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">getState</span>[<span style="color: #bbdaff;">S</span>]<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">FreeState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">S</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">Get</span>(s <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #bbdaff;">Done</span>(s)))

<span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">setState</span>[<span style="color: #bbdaff;">S</span>](s<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>)<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">FreeState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">Unit</span>] <span style="color: #d1f1a9;">=</span> <span style="color: #bbdaff;">More</span>(<span style="color: #bbdaff;">Put</span>(s, <span style="color: #bbdaff;">Done</span>()))
</pre>
</div>

<p>
执行一个 <code>State</code> 只需一个简单的循环:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">evalS</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>](s<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">S</span>, t<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">FreeState</span>[<span style="color: #bbdaff;">S</span>, <span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">A</span> <span style="color: #d1f1a9;">=</span> t.resume <span style="color: #d1f1a9;">match</span> {
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Left</span>(<span style="color: #bbdaff;">Get</span>(<span style="color: #ffeead;">f</span>)) <span style="color: #d1f1a9;">=&gt;</span> evalS(s, f(s))
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Left</span>(<span style="color: #bbdaff;">Put</span>(<span style="color: #ffeead;">n</span>, <span style="color: #ffeead;">a</span>)) <span style="color: #d1f1a9;">=&gt;</span> evalS(n, a)
  <span style="color: #d1f1a9;">case</span> <span style="color: #bbdaff;">Right</span>(<span style="color: #ffeead;">a</span>) <span style="color: #d1f1a9;">=&gt;</span> a
}
</pre>
</div>

<p>
现在我们可以在该 <code>Monad</code> 中写纯函数了. 比如, 一下是第一部分的 <code>zipIndex</code>, 这次我们用 <code>FreeState</code> 的 <code>Monda</code>:
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #d1f1a9;">def</span> <span style="color: #ffc58f;">zipIndex</span>[<span style="color: #bbdaff;">A</span>](as<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[<span style="color: #bbdaff;">A</span>])<span style="color: #d1f1a9;">:</span> <span style="color: #bbdaff;">List</span>[(<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">A</span>)] <span style="color: #d1f1a9;">=</span> evalS(<span style="color: #bbdaff;">0</span>, as.foldLeft(
  pureState[<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">List</span>[(<span style="color: #bbdaff;">Int</span>, <span style="color: #bbdaff;">A</span>)]](<span style="color: #bbdaff;">List</span>())) {
  (acc, a) <span style="color: #d1f1a9;">=&gt;</span> <span style="color: #d1f1a9;">for</span> {
    rs <span style="color: #d1f1a9;">&lt;-</span> acc
    n <span style="color: #d1f1a9;">&lt;-</span> getState
    <span style="color: #d1f1a9;">_</span> <span style="color: #d1f1a9;">&lt;-</span> setState(n + <span style="color: #bbdaff;">1</span>)
  } <span style="color: #d1f1a9;">yield</span> (n,a)::xs }).reverse
</pre>
</div>

<p>
实现的方式几乎是一致的, 同时在不使用 <code>Trampoline</code> 的情况下使用恒定的栈空间. 这里的结论是不需要总使用 <code>trampoline</code> 来封装数据类型. 可以使用新的 <code>Free Monad</code> 来实现同样的目的.
</p>
</div>
</div>
</div>

<div id="outline-container-orga74331f" class="outline-3">
<h3 id="orga74331f"><span class="section-number-3">3.9</span> 其它</h3>
<div class="outline-text-3" id="text-3-9">
<blockquote>
<p>
后续部分是作者对当前工作的总结和展望.
</p>
</blockquote>
</div>
</div>
</div>
